#include <iostream>
#include <string>
#include <fstream>
#include <vector>
#include <map>
#include <boost/filesystem.hpp>
#include <boost/regex.hpp>
using namespace std;
using namespace boost::filesystem;
using namespace boost;

void tableObjectGenerator(const path& output, pair<string, vector<pair<string, string>>> tabledef)
{
	string tableName = tabledef.first;
	std::fstream file(output.string() + "/" + tableName + ".h", std::fstream::out);
	if (tableName[0] <= 'z' && tableName[0] >= 'a')
	{
		tableName[0] -= 'a' - 'A';
	}
	for (size_t i = 0; i < tableName.size(); ++i)
	{
		if (tableName[i] == '_')
		{
			if (tableName[i + 1] <= 'z' && tableName[i + 1] >= 'a')
			{
				tableName[i+1] -= 'a' - 'A';
			}
			tableName = tableName.erase(i, 1);
			--i;
		}
	}
	file << "/************************************************************************************" << endl
		 << " *               Table: [" << tableName << "]                                 " << endl
		 <<	" *               Generated by inkneko dao_generator for mysql.                      " << endl
		 << " ************************************************************************************/" << endl;

	file << "#include <string>" << endl << endl;
	file << "struct " << tableName << endl;
	file << "{" << endl;
	for (auto row : tabledef.second)
	{
		file << "    ";
		string typeName = row.second;
		for (auto &c : typeName)
		{
			if (c >= 'a' && c <= 'z')
			{
				c -= 'a' - 'A';
			}
		}
		if (typeName == "TINYINT")
		{
			file << "short ";
		}
		else if (typeName == "INT")
		{
			file << "int ";
		}
		else if (typeName == "TINYTEXT" || typeName == "TEXT" || typeName == "DATETIME" || typeName.find("CHAR") != string::npos)
		{
			file << "std::string ";
		}
		else if (typeName == "TIMESTAMP" || typeName == "LONGINT")
		{
			file << "long ";
		}
		else
		{
			file << "unsupported: " << typeName << " ";
			cout << "unsupported: " << typeName << " at table [" << tableName << "]" <<  endl;
		}
		file << row.first << ";" << endl;
	}
	file << "}" << flush;
	cout << "\t" << "table [" << tableName << "] generated" << endl;
}


void generator(const path& output, map<string, vector<pair<string, string>>> database)
{
	create_directories(output);
	path tableDirectory(output);
	tableDirectory.append("table");
	create_directory(tableDirectory);

	for (auto e : database)
	{
		tableObjectGenerator(tableDirectory, e);
	}
}

map<string, vector<pair<string, string>>> parse(string sqlContent)
{
	//cout << sqlContent << flush;
	map<string, vector<pair<string, string>>> database;
	regex fmt("CREATE\\s+TABLE\\s+([a-zA-Z0-9_]+)\\s*\\(([^;]+)\\)[^;]+", regex::extended);
	regex_iterator<string::const_iterator> iter(sqlContent.cbegin(), sqlContent.cend(), fmt);
	for (auto index = iter; index != sregex_iterator(); ++index)
	{
		//cout << "table [" << index->str(1) << "] content: " << index->str(2) << endl;
		string table = index->str(1);
		string rowsText = index->str(2);

		regex rowfmt("([^\\s]+)\\s+([^\\s]+)[^,]+(,|)", regex::extended);
		regex_iterator<string::const_iterator> rowiter(rowsText.cbegin(), rowsText.cend(), rowfmt);
		vector<pair<string, string>> rows; //name : type(unsigned not supported)
		for (auto rowIndex = rowiter; rowIndex != sregex_iterator(); ++rowIndex)
		{
			rows.push_back({ rowIndex->str(1), rowIndex->str(2) });
		}

		cout << "table name [" << table << "], rows: " << endl;
		for (auto row : rows)
		{
			cout << '\t' << row.first << " -> " << row.second << endl;
		}
		database[table] = rows;
	}
	return database;

}

int main(int argc, char** argv)
{
	if (argc == 1)
	{
		return -1;
	}
	
	path enum_dir(argv[1]);
	directory_iterator enum_dir_iter(enum_dir);
	for (auto& entry : enum_dir_iter)
	{
		path sqlFilePath = canonical(entry.path());
		if (sqlFilePath.extension().string() == ".sql") 
		{
			std::fstream file(sqlFilePath.string(), std::fstream::in);
			cout << "[" << sqlFilePath.string() << "]" << "file content: " << endl;
			string line;
			string fileContent;
			while (getline(file, line))
			{
				fileContent += line + '\n';
				//cout << line << endl;
			}
			auto database = parse(fileContent);
			path databaseOutputDir(sqlFilePath.parent_path());
			string databaseName = sqlFilePath.filename().string();
			databaseName = databaseName.substr(0, databaseName.find('.'));
			databaseOutputDir.append(databaseName);
			for (auto table : database)
			{
				generator(databaseOutputDir, database);
			}
			
		}
	}


	
	return 0;
}